This is Hedgehog ðŸ¦”, a GraphQL server developed using
[PostGraphile](https://www.graphile.org/postgraphile), thus [PostgreSQL](https://www.postgresql.org/), too.

## Features

- Leverages the power of PostgreSQL. PostgreSQL is a powerful, open source object-relational database system that uses and extends the SQL language combined with many features that safely store and scale the most complicated data workloads. See [an overview](https://www.postgresql.org/about/) as well as [the feature matrix](https://www.postgresql.org/about/featurematrix/).
- Instant [GraphQL CRUD API](https://github.com/opencrud/opencrud) generated via PostgreSQL reflection API
- Very fast performance (see [here](https://medium.com/@Benjie/postgraphile-v4-released-9dcb117d3e69) and [here](https://medium.com/@Benjie/how-i-made-postgraphile-faster-than-prisma-graphql-server-in-8-hours-e66b4c511160))
- Hot reload that refreshes the API if the underlying database schema changes
- [Best practices](https://graphql.org/learn/best-practices/):
  - GraphQL connections (see [Original FB specs](http://facebook.github.io/relay/graphql/connections.htm), and [Explaining GraphQL Connections](https://blog.apollographql.com/explaining-graphql-connections-c48b7c3d6976))
  - Globally unique identifier for caching (nodeId)
  - Only expose what you need to (`--no-ignore-rbac`, namespaces, `@omit` smart comments)
  - Only expose what the server can execute efficiently (`--no-ignore-indexes`)
  - Make schema flexible to allow non-breaking changes (mutation payloads rather than returning new records directly)
  - Proper mutation design (see, for example, [Designing GraphQL Mutations](https://blog.apollographql.com/designing-graphql-mutations-e09de826ed97))
  - Documentation (autogenerated from PostgreSQL comments)
  - Serve over HTTP accepting `application/json` and `application/graphql` (`{"query": "...", "variables": {...}}`)
  - Avoid versioning (make non-breaking changes by adding deprecated computed fields/etc to replace the old fields)
  - [Sensible nullability](https://www.graphile.org/postgraphile/why-nullable/)
  - Efficient execution (no N+1 issues, advanced query planner, even better than the recommended DataLoader approach)
  - Server-side Batching & Caching (Experimental)
  - Customisation of the GraphQL schema via plugins and PostgreSQL comments.

## Routes

The application accepts `POST` requests on `/`, and (on non-production environments) exposes [GraphiQL](https://github.com/graphql/graphiql) on `/graphiql`.

## Package scripts

```js
"scripts": {
    "start": "postgraphile",
    "command:seed": "node commands/seed.js",
    "command:schema": "node commands/schema.js"
  },
```

### `start`

There is no `dev` or other "startup" script, since they would all be the same, simply executing `postgraphile`. The `postgraphile` executable will read its settings from `.postgraphilerc.js`. Please [refer to PostGraphile documentation](https://www.graphile.org/postgraphile/usage-cli/) for more information about those settings.

### `command:schema`

This is a utility implemented to load the schema and its updates on deployment. The main schema file, `schema/main.sql` must be kept up to date at all times. However, it will only be loaded on the first deployment of the application, when the database is found to be empty. Subsequent deployments will ignore that file, and look to find update files, `schema/update.([0-9]+).sql`. If these are found, their numbering is compared with the runtime configuration file located at `run/schema-config.json`, to determine what the latest update had been at the previous deployment, and run only the updates that came after it.

### `command:seed`

This utility uses a GraphQL binding approach to implement a seeding script for the application. Please refer to the script itself for more information about it.
